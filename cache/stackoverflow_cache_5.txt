disclaimer10m iterations ( coreclr ) :10m iterations ( framework ) :list < t > exposes 3 enumerators :i should point out the actual iteration in a list is rarely the bottleneck .keep in mind those are hundreds of milliseconds over millions of iterations .this is due to a subtlety on how c # selects it's enumerator for a given type .when c # compiles a foreach loop , it will select the enumerator in the above order .enumerating an ienumerable < t > is 2 to 3 times slower than enumerating the same list < t > directly .any work in the loop more complicated than a few arithmetic operations will be overwhelmingly costlier than the iteration itself .note that a type doesn't need to implement ienumerable or ienumerable < t > to be enumerable , it just needs a method named getenumerator ( ) that returns an enumerator .now , list < t > . getenumerator ( ) has the advantage of being statically typed which makes all calls to list < t > . enumerator . get_current and list < t > . enumerator . movenext ( ) static-bound instead of virtual .
